#!/bin/sh -e
# bzflag
# Copyright (c) 1993-2013 Tim Riker
#
# This package is free software;  you can redistribute it and/or
# modify it under the terms of the license found in the file
# named COPYING that should have accompanied this file.
#
# THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

# Import the BZFlag SourceForge Subversion repository into Git.  The
# complexity of this carefully tailored script mirrors the complexity
# generated by more than 70 people in 13+ years of development.

SOURCE="`dirname $0`"
SOURCE="`readlink -f $SOURCE`"			# use full path
MASTER_REPO="file://`cd $SOURCE && git rev-parse --git-dir`"
AUTHORS="$SOURCE/svn_authors"
UPSTREAM_REPO=https://svn.code.sf.net/p/bzflag/code
UPSTREAM_UUID=08b3d480-bf2c-0410-a26f-811ee3361c24
SVN_REPO=file:///scratch/bzflag/bzflag.svn	# $UPSTREAM_REPO will be much slower
STARTING_REVISION=1	# default
ENDING_REVISION=22829	# default, takes 3.5 hours on Bullet Catcher's computer

# There are some deficiencies of git-svn that must be overcome to
# faithfully import the BZFlag Subversion repository into Git.
# 
# The first is that git-svn often chooses the wrong parent commit for
# new branches and tags, especially when the parent is in a branch
# rather than on the trunk.  We work around this by stopping the
# import at empirically-determined revisions to rebase a commit onto
# the correct parent and then advancing the relevant branch head to
# include that commit before continuing.
# 
# Another is that git-svn does not know how to choose a parent for an
# empty commit (one that makes no changes to the tree), and simply
# bypasses it.  For completeness, we synthesize empty Git commits
# corresponding to the empty Subversion revisions.
#
# Multiple subproject directories in the Subversion "trunk" hierarchy
# are difficult to deal with when a branch of one is copied back to
# trunk.  Working from a database of exceptional commits is the way to
# success.

# parameters:
# 1 Subversion revision number
git_svn_fetch()
{
# import only the source code for the BZFlag game itself
# TODO: support other TARGET_REPO
git svn fetch -q -r $1 --authors-file=$AUTHORS --ignore-paths='^trunk/([^b]|..[^f])'
}

GIT_REPO_NAME=svn2git
if [ $# -gt 0 ] ; then
	TARGET_REPO=$1
	shift
	GIT_REPO_NAME="$GIT_REPO_NAME.$TARGET_REPO"
	if [ $# -gt 0 ] ; then
		STARTING_REVISION=$1
		shift
		if [ $# -gt 0 ] ; then
			ENDING_REVISION=$1
			shift
		fi
	fi
fi
cd /tmp		# use a tmpfs (ramdisk) file system for maximum speed
rm -rf $GIT_REPO_NAME
exec < /dev/null > $GIT_REPO_NAME.log 2>&1

git svn init $SVN_REPO --rewrite-root=$UPSTREAM_REPO --stdlayout $GIT_REPO_NAME
cd $GIT_REPO_NAME
# The git-svn documentation claims that --rewrite-root and
# --rewrite-uuid may be used together, but the code prohibits it.
# Edit the config file to work around this.
sed -i "/rewriteRoot/a\
\	rewriteUUID = $UPSTREAM_UUID" .git/config

IFS=,
set -x
while read rev repo method branch tag ; do
	case "$rev" in
	    \#*|'')
		;;	# ignore comments and blank lines
	    default)
		DEFAULT_REPO=$repo
		if [ -z "$TARGET_REPO" ] ; then
			TARGET_REPO=$DEFAULT_REPO
		fi
		NEXT_REVISION=$STARTING_REVISION
		echo default repo: $DEFAULT_REPO
		echo starting revision: $NEXT_REVISION
		;;
	    *)
		if [ $NEXT_REVISION -lt "$rev" ] ; then
			STOPPING_POINT=`expr $rev - 1`
			if [ $STOPPING_POINT -gt $ENDING_REVISION ] ; then
				STOPPING_POINT=$ENDING_REVISION
			fi
			if [ $NEXT_REVISION -lt $STOPPING_POINT ] ; then
				RANGE=${NEXT_REVISION}:$STOPPING_POINT
			elif [ $NEXT_REVISION -eq $STOPPING_POINT ] ; then
				RANGE=$NEXT_REVISION
			else
#				echo r$rev next revision $NEXT_REVISION must be less than or equal to $STOPPING_POINT
#				exit 1
				continue
			fi
			if [ $TARGET_REPO = $DEFAULT_REPO ] ; then
				git_svn_fetch $RANGE
				NEXT_REVISION=`expr $STOPPING_POINT + 1`
			else
				set +x	# hide lots of noise
				SKIPPED="`seq $NEXT_REVISION $STOPPING_POINT | xargs` $SKIPPED"
				set -x
				NEXT_REVISION=$rev
			fi
		fi
		if [ $NEXT_REVISION -le $ENDING_REVISION -a $NEXT_REVISION -eq "$rev" ] ; then
			if [ "x$repo" = "x$TARGET_REPO" ] ; then
				case "$method" in
				    auto)
					git_svn_fetch $rev
					;;
				    empty)
					# Synthesize an empty Git commit from Subversion.
					# Assumes the author has at least one previous commit.
					DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
					AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
					MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
					case "$branch" in
					    trunk|tags/*)
						LOCATION=$branch
						;;
					    *)
						LOCATION=branches/$branch
						;;
					esac
					git checkout remotes/$branch
					git commit --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"
					git rev-parse HEAD > .git/refs/remotes/$branch
					if [ $rev -eq 17840 ] ; then
						find .git -name v2_0_12 -exec rename -v 12 12.deleted {} +
					fi
					;;
				    rebase_branch|rebase_branch_inline)	# move branch to correct parent
					new_parent=remotes/$branch
					git rev-parse --verify $new_parent
					if [ -z "$tag" ] ; then
						echo r$rev requires a source branch in the tag field
						exit 1
					fi
					source_branch=remotes/$tag
					git_svn_fetch $rev
					git rev-parse --verify $source_branch
					if git rev-parse --verify ${source_branch}~ ; then
						onto="--onto $new_parent ${source_branch}~"
					else
						onto=$new_parent
					fi
					# extra effort is required to rebase a lone empty commit
					if ! eval git rebase --keep-empty $onto $source_branch ; then
						if [ $rev -eq 21396 ] ; then
							git add bzflag/include/PlayerInfo.h
							if [ -d $repo/src/other ] ; then
								find $repo/src/other -depth -exec rmdir {} +	# only needed for a partial repo
							fi
							sed -i '1,/^git-svn-id:/!d' .git/MERGE_MSG
							git commit --allow-empty -F .git/MERGE_MSG
						else
							git commit --allow-empty -F .git/COMMIT_EDITMSG
						fi
						git cherry-pick --continue
					fi
					git rev-parse HEAD > .git/refs/$source_branch
					if [ $method = rebase_branch_inline ] ; then
						git rev-parse HEAD > .git/refs/$new_parent
					fi
					;;
				    cherry_pick_branch_up|cherry_pick_branch_down_inline)	# move to correct parent with sliding top-level directory
					if [ -z "$tag" ] ; then
						echo r$rev requires a tag or source branch
						exit 1
					fi
					git_svn_fetch $rev
					git rev-parse --verify remotes/$tag
					git checkout remotes/$branch
					git cherry-pick --allow-empty --no-commit remotes/$tag
					if [ $method = cherry_pick_branch_up ] ; then
						git rm -q -r $repo
					else
						git reset HEAD
						rm -r $repo
						mkdir .bzFLAG
						if [ -f .cvsignore ] ; then
							mv .cvsignore .bzFLAG
						fi
						mv * .bzFLAG
						mv .bzFLAG $repo
						git add --all
					fi
					DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
					AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
					MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
					case "$tag" in
					    trunk|tags/*)
						LOCATION=$tag
						;;
					    *)
						LOCATION=branches/$tag
						;;
					esac
					git commit --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"
					git rev-parse HEAD > .git/refs/remotes/$tag
					if [ $method = cherry_pick_branch_down_inline ] ; then
						git rev-parse HEAD > .git/refs/remotes/$branch
					fi
					;;
				    rebase_tag_branch|rebase_tag_inline)	# move tag to correct parent
					case "$branch" in
					    :*)
						new_parent=`git rev-parse $branch`
						;;
					    *)
						new_parent=remotes/$branch
						git rev-parse --verify $new_parent
						;;
					esac
					git_svn_fetch $rev
					git rev-parse --verify remotes/tags/$tag
					if git rev-parse --verify remotes/tags/${tag}~ ; then
						onto="--onto $new_parent remotes/tags/${tag}~"
					else
						onto=$new_parent
					fi
					# extra effort is required to rebase a lone empty commit
					if ! eval git rebase --keep-empty $onto remotes/tags/$tag ; then
						if [ $rev -eq 6881 ] ; then
							git status | awk '/added by us|deleted by them/ {print $5}' | xargs git rm
							git rm -r bzflag/include bzflag/src bzflag/win32/VC71
							sed '1,/^git-svn-id:/!d' .git/MERGE_MSG > .git/COMMIT_EDITMSG
						fi
						git commit --allow-empty -F .git/COMMIT_EDITMSG
						git cherry-pick --continue
					fi
					git rev-parse HEAD > .git/refs/remotes/tags/$tag
					if [ $method = rebase_tag_inline ] ; then
						git rev-parse HEAD > .git/refs/remotes/$branch
					fi
					;;
				    rebase_r1586)	# r1586 mostly copies the v1_7 branch onto trunk (r1587 finishes the job)
					git_svn_fetch $rev
					git rebase --keep-empty --onto remotes/tags/v1_7temp remotes/trunk~ remotes/trunk || true
					for file in bzflag/src/platform/MacBZFlag-prefix.h bzflag/src/platform/MacOSX/MacBZFlag-prefix.h ; do
						mv -i ${file}~[0-9a-f]* $file
						rm ${file}~HEAD
					done
					git rm bzflag/data/boxwall.rgb
					git status | awk '/added by us|deleted by them/ {print $5}' | xargs git rm
					git status | awk '/deleted by us|added by them/ {print $5}' | xargs git add
					sed -i '1,/^git-svn-id:/!d' .git/MERGE_MSG
					git commit --allow-empty -F .git/MERGE_MSG
					git cherry-pick --continue
					git rev-parse HEAD > .git/refs/remotes/trunk
					;;
				    inline_tag)	# bring inline an empty branched tag
					git rev-parse --verify remotes/$branch
					if [ -z "$tag" ] ; then
						echo r$rev requires a tag
						exit 1
					fi
					git_svn_fetch $rev
					git rev-parse remotes/tags/$tag > .git/refs/remotes/$branch
					;;
				    merge*)
					case "$tag" in
					    '')
						echo r$rev requires a source branch in the tag field
						exit 1
						;;
					    :*)
						source_branch=`git rev-parse $tag`
						;;
					    *)
						source_branch=remotes/$tag
						git rev-parse --verify $source_branch
						;;
					esac
					git checkout remotes/$branch
					if [ "x$branch" = xtrunk ] ; then
						LOCATION=$branch
					else
						LOCATION=branches/$branch
					fi
					git merge -q `echo $method | sed 's/^merge//'` --no-commit $source_branch
					if [ $rev -eq 2069 ] ; then
						for file in include/Flag.h src/bzflag/playing.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12017 ] ; then
						for file in include/PlayerInfo.h include/bzfsAPI.h include/global.h misc/bzfs.conf src/bzflag/Player.h src/bzflag/ScoreboardRenderer.cxx src/bzfs/bzfs.cxx src/game/PlayerInfo.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							if [ $file = src/bzflag/ScoreboardRenderer.cxx ] ; then
								sed -i 's/\$Id: .* \$/$Id$/' bzflag/$file
							fi
							git add bzflag/$file
						done
					elif [ $rev -eq 12039 ] ; then
						for file in src/bzflag/LocalPlayer.cxx src/bzfs/bzfs.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12060 ] ; then
						for file in src/bzadmin/bzadmin.cxx src/bzfs/CmdLineOptions.cxx src/bzfs/GameKeeper.h src/bzfs/bzfs.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12109 ] ; then
						for file in src/bzfs/GameKeeper.h src/bzfs/bzfs.cxx src/bzfs/commands.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12166 ] ; then
						for file in include/bzfsAPI.h plugins/doc/events.html src/bzadmin/CursesMenu.cxx src/bzfs/bzfs.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12258 ] ; then
						for file in ChangeLog src/bzadmin/bzadmin.cxx src/bzflag/BackgroundRenderer.cxx src/bzflag/BackgroundRenderer.h src/bzflag/HUDRenderer.cxx src/bzflag/SceneRenderer.cxx src/bzflag/ScoreboardRenderer.cxx src/bzflag/SegmentedShotStrategy.cxx src/bzflag/ShockWaveStrategy.cxx src/bzflag/playing.cxx src/bzfs/CmdLineOptions.cxx src/bzfs/GameKeeper.h src/bzfs/bzfs.cxx src/bzfs/commands.cxx src/common/AutoCompleter.cxx src/game/PlayerInfo.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12396 ] ; then
						for file in ChangeLog src/bzfs/bzfs.cxx src/bzfs/bzfsAPI.cxx src/bzfs/commands.cxx src/common/TimeBomb.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12504 ] ; then
						for file in ChangeLog plugins/logDetail/logDetail.cpp src/bzflag/KeyboardMapMenu.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12688 ] ; then
						for file in ChangeLog README.MacOSX README.WIN32 configure.ac data/title.png include/bzfsAPI.h package/win32/nsis/Makefile.am plugins/HoldTheFlag/HoldTheFlag.cpp src/bzflag/GUIOptionsMenu.cxx src/bzflag/ScoreboardRenderer.cxx src/bzflag/ScoreboardRenderer.h src/bzflag/clientCommands.cxx src/bzflag/defaultBZDB.cxx src/bzfs/CmdLineOptions.h src/bzfs/SpawnPosition.cxx src/bzfs/bzfs.cxx src/bzfs/bzfsAPI.cxx src/bzfs/commands.cxx src/common/TextChunkManager.cxx win32/Makefile.am win32/VC71/bzadmin.vcproj win32/VC71/bzfs.vcproj ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							if [ $file = configure.ac -o $file = plugins/HoldTheFlag/HoldTheFlag.cpp -o $file = src/bzflag/ScoreboardRenderer.cxx ] ; then
								sed -i -e 's/\$Id: .* \$/$Id$/' -e 's/\$Revision: .* \$/$Revision$/' bzflag/$file
							fi
							git add bzflag/$file
						done
					elif [ $rev -eq 12828 ] ; then
						for file in Dev-C++/bzfs.dev README.DEVC++ README.WIN32 configure.ac include/TextUtils.h include/bzfsAPI.h include/common.h package/win32/README.win32.html package/win32/nsis/BZFlag.nsi package/win32/nsis/Makefile.am plugins/nagware/CHANGELOG.txt plugins/nagware/NAGSAMPLE.cfg plugins/nagware/nagware.cpp src/bzflag/CommandsImplementation.cxx src/bzflag/World.cxx src/bzflag/effectsRenderer.cxx src/bzflag/effectsRenderer.h src/bzflag/playing.cxx src/bzfs/bzfs.cxx src/bzfs/bzfsAPI.cxx src/bzfs/commands.cxx src/geometry/BillboardSceneNode.cxx src/geometry/BoltSceneNode.cxx src/mediafile/MediaFile.cxx win32/VC71/bzadmin.vcproj win32/VC71/common.vcproj ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							if [ $file = configure.ac -o $file = plugins/nagware/nagware.cpp ] ; then
								sed -i -e 's/\$Id: .* \$/$Id$/' -e 's/\$Revision: .* \$/$Revision$/' bzflag/$file
							fi
							git add bzflag/$file
						done
					fi
					DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
					AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
					MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
					git commit --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"
					git rev-parse HEAD > .git/refs/remotes/$branch
					;;
				    *)
					echo "<$rev> <$repo> <$method> (not implemented) <$branch> <$tag>"
					exit 1
					;;
				esac
			else
				echo skipping $repo r$rev
				set +x	# hide lots of noise
				SKIPPED="$rev $SKIPPED"
				set -x
			fi
			NEXT_REVISION=`expr $NEXT_REVISION + 1`
#		else
#			echo "r$rev is out of sequence"
#			exit 1
		fi
		;;
	esac
done < $SOURCE/revision_list

set +x	# hide lots of noise
( seq $STARTING_REVISION $ENDING_REVISION
  # these Subversion revisions appear as two Git commits because each changes both trunk and a branch
  for r in 298 722 4194 4195 4197 4198 5793 5794 5943 5997 5998 6006 6007 6008 6084 6130 6162 6170 6171 6204 6455 6456 6459 6492 6654 6706 6789 6909 7461 7462 7468 7587 7828 8480 11953 11974 12096 12102 12103 12104 12205 12355 12362 12450 12523 12524 12529 12550 12653 12797 12801 12803 12815 13008 13053 13152 13226 13247 13300 13328 13581 13585 13653 13654 13655 13656 13660 13664 13665 13667 13679 13680 13706 13782 13801 13842 13913 13915 ; do
	if [ $STARTING_REVISION -le $r -a $r -le $ENDING_REVISION ] ; then
		echo $r
	fi
  done
) | sort -n > /tmp/$GIT_REPO_NAME.expect
( git log --all | awk '$1 == "git-svn-id:" && $3 == "08b3d480-bf2c-0410-a26f-811ee3361c24" {print substr($2,index($2,"@")+1)}'
  echo -n "$SKIPPED" | tr ' ' \\n
) | sort -n > /tmp/$GIT_REPO_NAME.have
if cmp -s /tmp/$GIT_REPO_NAME.expect /tmp/$GIT_REPO_NAME.have ; then
	echo "All revisions accounted for."
else
	echo "expected vs. actual subversion commits:"
	diff /tmp/$GIT_REPO_NAME.expect /tmp/$GIT_REPO_NAME.have || true
fi
rm /tmp/$GIT_REPO_NAME.expect /tmp/$GIT_REPO_NAME.have
set -x

# change all committer info to match the author's
# move files up out of repo name subdirectory
# (the file name bzFLAG is known not to conflict with anything)
# "--subdirectory-filter bzflag" removes empty commits and so is unsuitable
time git filter-branch --env-filter 'export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME";export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL";export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"' --tree-filter "if mv $TARGET_REPO bzFLAG ; then mv bzFLAG/.??* bzFLAG/* . || true ; rmdir bzFLAG ; fi" -- --all | tr \\r \\n
rm -rf .git/refs/original	# discard old commits saved by filter-branch 
git checkout remotes/trunk	# set HEAD

exit 0

# clean up branches
git branch -d -r v2_99continuing		# not ready for this branch now
git rebase --keep-empty tags/v2_4_2 master	# bring branched tag inline
git branch -d -r trunk
git rebase --keep-empty tags/v2_4_0 master	# bring branched tag inline
git rebase --keep-empty --onto `git rev-parse 'master^{/@22531.08b3d480}'` \
 remotes/2_4_OSX_Lion_Rebuild_branch~4 \
 remotes/2_4_OSX_Lion_Rebuild_branch
git branch OSX_Lion_rebuild HEAD		# rebase leaves HEAD at a convenient place
git branch -d -r 2_4_OSX_Lion_Rebuild_branch

# establish tags
git branch -d -r tags/v2_4_2
git tag v2.4.2 `git rev-parse :/@22528.08b3d480`	# r22528
git branch -d -r tags/v2_4_0
git tag v2.4.0 `git rev-parse :/@22053.08b3d480`	# r22053

git branch -m master v2_4_x		# give the branch a meaningful name
git branch v2_6_x v2_4_x		# create new development branch

# Import post-Subversion changes, rewriting history to make it look like
# 2.4.x compatible changes were actually committed to the v2_4_x branch.
git checkout v2_4_x			# be sure to start at the right place
git remote add -f alpha $HOME/bzflag/bzflag.git
git cherry-pick 3fedeb3..dcc5ae4	# Update with git info
git cherry-pick aed50ba			# Add a .gitignore file
git cherry-pick c9ec8bd			# Don't ignore .dsp and .dsw files
git cherry-pick b3b2444			# ignore windows temp and bin files
git cherry-pick 084c020..af6a459	# ingnore more windows temp files
git checkout v2_6_x
git cherry-pick 373570a..3fedeb3	# update version
# JeffM would have done this if he were actually committing to the v2_4_x branch
GIT_AUTHOR_DATE='1373139800 -0700' GIT_AUTHOR_NAME='Jeffery Myers' GIT_AUTHOR_EMAIL='jeffm2501@gmail.com' git merge "-mMerge branch 'v2_4_x'" v2_4_x
git cherry-pick 514748b			# Bump the BZFS protocol number ...
git cherry-pick f37d6ed			# Change the BZFlag version number ...
git checkout v2_4_x
git cherry-pick 514748b..d140a69	# No more acceptance, just read on wiki
git cherry-pick 82cb3e0..4d58043	# Build only a dynamic library ...
git cherry-pick 68c7a06			# Use "git ls-files" to get the ...
git cherry-pick 4717a78			# Add 2 more files to the list of ...
git cherry-pick c970ee6..70418c7	# For observers, do not flash GAME ...
git checkout v2_6_x
GIT_AUTHOR_DATE='1376370000 -0700' git merge '-mMerge branch v2_4_x onto branch v2_6_x.' v2_4_x
git checkout v2_4_x
git cherry-pick 76263f1..6afb5e0	# Bring the list of changes in ...
git cherry-pick 68c7a06..fe34967	# remove files that were not ready ...
git checkout v2_6_x
GIT_AUTHOR_DATE='1376861008 -0700' git merge '-mMerge recent v2_4_x changes into v2_6_x.' v2_4_x
git remote remove alpha
git tag -d `git tag | fgrep -v .`	# expunge alpha tags

# change all committer info to match the author
git filter-branch --env-filter 'export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME";export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL";export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"' -- --all | tr \\015 \\012
rm -r .git/refs/original	# discard old commits saved by filter-branch 

# set the master branch to unborn state
echo ref: refs/heads/master > .git/HEAD
rm -r .gitignore *
git rm -q -r --cached .

git remote add -f blaster $MASTER_REPO			# import master branch
git branch --track master remotes/blaster/master	# disconnected master branch
git remote remove blaster				# disconnect from repo
git reset --hard HEAD					# checkout master branch

sleep 1						# let the clock advance
git reflog expire --expire=now --all		# purge reflogs
git gc --prune=now				# rewritten commits be gone!
rm .git/COMMIT_EDITMSG .git/FETCH_HEAD		# tidy
rm -r .git/logs/refs/remotes .git/refs/remotes	# tidy
git status --ignored				# update index and show state

# 11 minutes elapsed time on Bullet Catcher's computer

exit 0
# Push this to a new empty repo at GitHub:
git remote add origin git@github.com:BZFlag-Dev/bzflag-import-2.git
git push -u origin master
git push -u origin --all
git push -u origin --tags
