#!/bin/sh -e
# bzflag
# Copyright (c) 1993-2013 Tim Riker
#
# This package is free software;  you can redistribute it and/or
# modify it under the terms of the license found in the file
# named COPYING that should have accompanied this file.
#
# THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

# Import the BZFlag SourceForge Subversion repository into Git.  The
# complexity of this carefully tailored script mirrors the complexity
# generated by more than 70 people in 13+ years of development.

SOURCE="`dirname $0`"
SOURCE="`readlink -f $SOURCE`"			# use full path
MASTER_REPO="file://`cd $SOURCE && git rev-parse --git-dir`"
AUTHORS="$SOURCE/svn_authors"
UPSTREAM_REPO=https://svn.code.sf.net/p/bzflag/code
UPSTREAM_UUID=08b3d480-bf2c-0410-a26f-811ee3361c24
SVN_REPO=file:///scratch/bzflag/bzflag.svn	# $UPSTREAM_REPO will be much slower
STARTING_REVISION=1	# default
ENDING_REVISION=22828	# default, takes 3.5 hours on Bullet Catcher's computer

# There are some deficiencies of git-svn that must be overcome to
# faithfully import the BZFlag Subversion repository into Git.
# 
# The first is that git-svn often chooses the wrong parent commit for
# new branches and tags, especially when the parent is in a branch
# rather than on the trunk.  We work around this by stopping the
# import at empirically-determined revisions to rebase a commit onto
# the correct parent and then advancing the relevant branch head to
# include that commit before continuing.
# 
# Another is that git-svn does not know how to choose a parent for an
# empty commit (one that makes no changes to the tree), and simply
# bypasses it.  For completeness, we synthesize empty Git commits
# corresponding to the empty Subversion revisions.
#
# Multiple subproject directories in the Subversion "trunk" hierarchy
# are difficult to deal with when a branch of one is copied back to
# trunk.  Working from a database of exceptional commits is the way to
# success.

# parameters:
# 1 Subversion revision number
git_svn_fetch()
{
# import only the source code for the BZFlag game itself
# TODO: support other TARGET_REPO
git svn fetch -q -r $1 --authors-file=$AUTHORS --ignore-paths=$IGNORE_PATHS
}

GIT_REPO_NAME=svn2git
if [ $# -gt 0 ] ; then
	TARGET_REPO=$1
	shift
	GIT_REPO_NAME="$GIT_REPO_NAME.$TARGET_REPO"
	if [ $# -gt 0 ] ; then
		STARTING_REVISION=$1
		shift
		if [ $# -gt 0 ] ; then
			ENDING_REVISION=$1
			shift
		fi
	fi
fi
cd /tmp		# use a tmpfs (ramdisk) file system for maximum speed
rm -rf $GIT_REPO_NAME
exec < /dev/null > $GIT_REPO_NAME.log 2>&1

git svn init $SVN_REPO --rewrite-root=$UPSTREAM_REPO --stdlayout $GIT_REPO_NAME
cd $GIT_REPO_NAME
# The git-svn documentation claims that --rewrite-root and
# --rewrite-uuid may be used together, but the code prohibits it.
# Edit the config file to work around this.
sed -i "/rewriteRoot/a\
\	rewriteUUID = $UPSTREAM_UUID" .git/config

SAVEIFS="$IFS"
IFS=,
set -x
while read rev repo method branch tag ; do
	case "$rev" in
	    \#*|'')
		;;	# ignore comments and blank lines
	    default)
		DEFAULT_REPO=$repo
		if [ -z "$TARGET_REPO" ] ; then
			TARGET_REPO=$DEFAULT_REPO
		fi
		case $TARGET_REPO in
		    admin)
			IGNORE_PATHS='^trunk/[^a]'
			;;
		    bzauthd)
			IGNORE_PATHS='^trunk/([^b]|..[^a])'
			;;
		    bzedit)
			IGNORE_PATHS='^trunk/([^b]|..[^e])'	# TODO fix
			;;
		    bzeditw32)
			IGNORE_PATHS='^trunk/([^b]|..[^e])'	# TODO fix
			;;
		    bzflag)
			IGNORE_PATHS='^trunk/([^b]|..[^f])'
			;;
		    bzstats)
			IGNORE_PATHS='^trunk/([^b]|..[^s])'
			;;
		    bzwgen)
			IGNORE_PATHS='^trunk/([^b]|...[^g])'
			;;
		    bzworkbench)
			IGNORE_PATHS='^trunk/([^b]|...[^o])'
			;;
		    db)
			IGNORE_PATHS='^trunk/[^d]'
			;;
		    pybzflag)
			IGNORE_PATHS='^trunk/[^p]'
			;;
		    web)
			IGNORE_PATHS='^trunk/[^w]'
			;;
		    *)
			echo "No such repo '$TARGET_REPO'"
			exit 1
			;;
		esac
		NEXT_REVISION=$STARTING_REVISION
		echo default repo: $DEFAULT_REPO
		echo starting revision: $NEXT_REVISION
		;;
	    *)
		if [ $NEXT_REVISION -lt "$rev" ] ; then
			STOPPING_POINT=`expr $rev - 1`
			if [ $STOPPING_POINT -gt $ENDING_REVISION ] ; then
				STOPPING_POINT=$ENDING_REVISION
			fi
			if [ $NEXT_REVISION -lt $STOPPING_POINT ] ; then
				RANGE=${NEXT_REVISION}:$STOPPING_POINT
			elif [ $NEXT_REVISION -eq $STOPPING_POINT ] ; then
				RANGE=$NEXT_REVISION
			else
#				echo r$rev next revision $NEXT_REVISION must be less than or equal to $STOPPING_POINT
#				exit 1
				continue
			fi
			if [ $TARGET_REPO = $DEFAULT_REPO ] ; then
				git_svn_fetch $RANGE
				NEXT_REVISION=`expr $STOPPING_POINT + 1`
			else
				set +x	# hide lots of noise
				SKIPPED="`seq $NEXT_REVISION $STOPPING_POINT | xargs` $SKIPPED"
				set -x
				NEXT_REVISION=$rev
			fi
		fi
		if [ $NEXT_REVISION -le $ENDING_REVISION -a $NEXT_REVISION -eq "$rev" ] ; then
			if [ "x$repo" = "x$TARGET_REPO" ] ; then
				case "$method" in
				    auto)
					git_svn_fetch $rev
					;;
				    empty)
					# Synthesize an empty Git commit from Subversion.
					# Assumes the author has at least one previous commit.
					DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
					AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
					MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
					case "$branch" in
					    trunk|tags/*)
						LOCATION=$branch
						;;
					    *)
						LOCATION=branches/$branch
						;;
					esac
					git checkout remotes/$branch
					git commit --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"
					git rev-parse HEAD > .git/refs/remotes/$branch
					if [ $rev -eq 17840 ] ; then
						find .git -name v2_0_12 -exec rename -v 12 12.deleted {} +
					fi
					;;
				    rebase_branch|rebase_branch_inline)	# move branch to correct parent
					new_parent=remotes/$branch
					git rev-parse --verify $new_parent
					if [ -z "$tag" ] ; then
						echo r$rev requires a source branch in the tag field
						exit 1
					fi
					source_branch=remotes/$tag
					git_svn_fetch $rev
					git rev-parse --verify $source_branch
					if git rev-parse --verify ${source_branch}~ ; then
						onto="--onto $new_parent ${source_branch}~"
					else
						onto=$new_parent
					fi
					# extra effort is required to rebase a lone empty commit
					if ! eval git rebase --keep-empty $onto $source_branch ; then
						if [ $rev -eq 21396 ] ; then
							git add bzflag/include/PlayerInfo.h
							if [ -d $repo/src/other ] ; then
								find $repo/src/other -depth -exec rmdir {} +	# only needed for a partial repo
							fi
							sed -i '1,/^git-svn-id:/!d' .git/MERGE_MSG
							git commit --allow-empty -F .git/MERGE_MSG
						else
							git commit --allow-empty -F .git/COMMIT_EDITMSG
						fi
						git cherry-pick --continue
					fi
					git rev-parse HEAD > .git/refs/$source_branch
					if [ $method = rebase_branch_inline ] ; then
						git rev-parse HEAD > .git/refs/$new_parent
					fi
					;;
				    cherry_pick_branch_up|cherry_pick_branch_down_inline)	# move to correct parent with sliding top-level directory
					if [ -z "$tag" ] ; then
						echo r$rev requires a tag or source branch
						exit 1
					fi
					git_svn_fetch $rev
					git rev-parse --verify remotes/$tag
					git checkout remotes/$branch
					git cherry-pick --allow-empty --no-commit remotes/$tag
					if [ $method = cherry_pick_branch_up ] ; then
						git rm -q -r $repo
					else
						git reset HEAD
						rm -r $repo
						mkdir .bzFLAG
						mv .[^g]?* * .bzFLAG || true	# don't move the .git directory
						mv .bzFLAG $repo
						git add --all
					fi
					DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
					AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
					MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
					case "$tag" in
					    trunk|tags/*)
						LOCATION=$tag
						;;
					    *)
						LOCATION=branches/$tag
						;;
					esac
					git commit --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"
					git rev-parse HEAD > .git/refs/remotes/$tag
					if [ $method = cherry_pick_branch_down_inline ] ; then
						git rev-parse HEAD > .git/refs/remotes/$branch
					fi
					;;
				    rebase_tag_branch|rebase_tag_inline)	# move tag to correct parent
					case "$branch" in
					    :*)
						new_parent=`git rev-parse $branch`
						;;
					    *)
						new_parent=remotes/$branch
						git rev-parse --verify $new_parent
						;;
					esac
					git_svn_fetch $rev
					git rev-parse --verify remotes/tags/$tag
					if git rev-parse --verify remotes/tags/${tag}~ ; then
						onto="--onto $new_parent remotes/tags/${tag}~"
					else
						onto=$new_parent
					fi
					# extra effort is required to rebase a lone empty commit
					if ! eval git rebase --keep-empty $onto remotes/tags/$tag ; then
						if [ $rev -eq 6881 ] ; then
							git status | awk '/added by us|deleted by them/ {print $5}' | xargs git rm
							git rm -r bzflag/include bzflag/src bzflag/win32/VC71
							sed '1,/^git-svn-id:/!d' .git/MERGE_MSG > .git/COMMIT_EDITMSG
						fi
						git commit --allow-empty -F .git/COMMIT_EDITMSG
						git cherry-pick --continue
					fi
					git rev-parse HEAD > .git/refs/remotes/tags/$tag
					if [ $method = rebase_tag_inline ] ; then
						git rev-parse HEAD > .git/refs/remotes/$branch
					fi
					;;
				    rebase_r1586)	# r1586 mostly copies the v1_7 branch onto trunk (r1587 finishes the job)
					git_svn_fetch $rev
					git rebase --keep-empty --onto remotes/tags/v1_7temp remotes/trunk~ remotes/trunk || true
					for file in bzflag/src/platform/MacBZFlag-prefix.h bzflag/src/platform/MacOSX/MacBZFlag-prefix.h ; do
						mv -i ${file}~[0-9a-f]* $file
						rm ${file}~HEAD
					done
					git rm bzflag/data/boxwall.rgb
					git status | awk '/added by us|deleted by them/ {print $5}' | xargs git rm
					git status | awk '/deleted by us|added by them/ {print $5}' | xargs git add
					sed -i '1,/^git-svn-id:/!d' .git/MERGE_MSG
					git commit --allow-empty -F .git/MERGE_MSG
					git cherry-pick --continue
					git rev-parse HEAD > .git/refs/remotes/trunk
					;;
				    inline_tag)	# bring inline an empty branched tag
					git rev-parse --verify remotes/$branch
					if [ -z "$tag" ] ; then
						echo r$rev requires a tag
						exit 1
					fi
					git_svn_fetch $rev
					git rev-parse remotes/tags/$tag > .git/refs/remotes/$branch
					;;
				    merge*)
					case "$tag" in
					    '')
						echo r$rev requires a source branch in the tag field
						exit 1
						;;
					    :*)
						source_branch=`git rev-parse $tag`
						;;
					    *)
						source_branch=remotes/$tag
						git rev-parse --verify $source_branch
						;;
					esac
					git checkout remotes/$branch
					if [ "x$branch" = xtrunk ] ; then
						LOCATION=$branch
					else
						LOCATION=branches/$branch
					fi
					git merge -q `echo $method | sed 's/^merge//'` --no-commit $source_branch
					if [ $rev -eq 2069 ] ; then
						for file in include/Flag.h src/bzflag/playing.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12017 ] ; then
						for file in include/PlayerInfo.h include/bzfsAPI.h include/global.h misc/bzfs.conf src/bzflag/Player.h src/bzflag/ScoreboardRenderer.cxx src/bzfs/bzfs.cxx src/game/PlayerInfo.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							if [ $file = src/bzflag/ScoreboardRenderer.cxx ] ; then
								sed -i 's/\$Id: .* \$/$Id$/' bzflag/$file
							fi
							git add bzflag/$file
						done
					elif [ $rev -eq 12039 ] ; then
						for file in src/bzflag/LocalPlayer.cxx src/bzfs/bzfs.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12060 ] ; then
						for file in src/bzadmin/bzadmin.cxx src/bzfs/CmdLineOptions.cxx src/bzfs/GameKeeper.h src/bzfs/bzfs.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12109 ] ; then
						for file in src/bzfs/GameKeeper.h src/bzfs/bzfs.cxx src/bzfs/commands.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12166 ] ; then
						for file in include/bzfsAPI.h plugins/doc/events.html src/bzadmin/CursesMenu.cxx src/bzfs/bzfs.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12258 ] ; then
						for file in ChangeLog src/bzadmin/bzadmin.cxx src/bzflag/BackgroundRenderer.cxx src/bzflag/BackgroundRenderer.h src/bzflag/HUDRenderer.cxx src/bzflag/SceneRenderer.cxx src/bzflag/ScoreboardRenderer.cxx src/bzflag/SegmentedShotStrategy.cxx src/bzflag/ShockWaveStrategy.cxx src/bzflag/playing.cxx src/bzfs/CmdLineOptions.cxx src/bzfs/GameKeeper.h src/bzfs/bzfs.cxx src/bzfs/commands.cxx src/common/AutoCompleter.cxx src/game/PlayerInfo.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12396 ] ; then
						for file in ChangeLog src/bzfs/bzfs.cxx src/bzfs/bzfsAPI.cxx src/bzfs/commands.cxx src/common/TimeBomb.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12504 ] ; then
						for file in ChangeLog plugins/logDetail/logDetail.cpp src/bzflag/KeyboardMapMenu.cxx ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							git add bzflag/$file
						done
					elif [ $rev -eq 12688 ] ; then
						for file in ChangeLog README.MacOSX README.WIN32 configure.ac data/title.png include/bzfsAPI.h package/win32/nsis/Makefile.am plugins/HoldTheFlag/HoldTheFlag.cpp src/bzflag/GUIOptionsMenu.cxx src/bzflag/ScoreboardRenderer.cxx src/bzflag/ScoreboardRenderer.h src/bzflag/clientCommands.cxx src/bzflag/defaultBZDB.cxx src/bzfs/CmdLineOptions.h src/bzfs/SpawnPosition.cxx src/bzfs/bzfs.cxx src/bzfs/bzfsAPI.cxx src/bzfs/commands.cxx src/common/TextChunkManager.cxx win32/Makefile.am win32/VC71/bzadmin.vcproj win32/VC71/bzfs.vcproj ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							if [ $file = configure.ac -o $file = plugins/HoldTheFlag/HoldTheFlag.cpp -o $file = src/bzflag/ScoreboardRenderer.cxx ] ; then
								sed -i -e 's/\$Id: .* \$/$Id$/' -e 's/\$Revision: .* \$/$Revision$/' bzflag/$file
							fi
							git add bzflag/$file
						done
					elif [ $rev -eq 12828 ] ; then
						for file in Dev-C++/bzfs.dev README.DEVC++ README.WIN32 configure.ac include/TextUtils.h include/bzfsAPI.h include/common.h package/win32/README.win32.html package/win32/nsis/BZFlag.nsi package/win32/nsis/Makefile.am plugins/nagware/CHANGELOG.txt plugins/nagware/NAGSAMPLE.cfg plugins/nagware/nagware.cpp src/bzflag/CommandsImplementation.cxx src/bzflag/World.cxx src/bzflag/effectsRenderer.cxx src/bzflag/effectsRenderer.h src/bzflag/playing.cxx src/bzfs/bzfs.cxx src/bzfs/bzfsAPI.cxx src/bzfs/commands.cxx src/geometry/BillboardSceneNode.cxx src/geometry/BoltSceneNode.cxx src/mediafile/MediaFile.cxx win32/VC71/bzadmin.vcproj win32/VC71/common.vcproj ; do
							svn cat $SVN_REPO/$LOCATION/bzflag/$file@$rev > bzflag/$file
							if [ $file = configure.ac -o $file = plugins/nagware/nagware.cpp ] ; then
								sed -i -e 's/\$Id: .* \$/$Id$/' -e 's/\$Revision: .* \$/$Revision$/' bzflag/$file
							fi
							git add bzflag/$file
						done
					fi
					DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
					AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
					MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
					git commit --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"
					git rev-parse HEAD > .git/refs/remotes/$branch
					;;
				    *)
					echo "<$rev> <$repo> <$method> (not implemented) <$branch> <$tag>"
					exit 1
					;;
				esac
			else
				echo skipping $repo r$rev
				set +x	# hide lots of noise
				SKIPPED="$rev $SKIPPED"
				set -x
			fi
			NEXT_REVISION=`expr $NEXT_REVISION + 1`
#		else
#			echo "r$rev is out of sequence"
#			exit 1
		fi
		;;
	esac
done < $SOURCE/revision_list
IFS="$SAVEIFS"

set +x	# hide lots of noise
( seq $STARTING_REVISION $ENDING_REVISION
  # these Subversion revisions appear as two Git commits because each changes both trunk and a branch
  if [ $TARGET_REPO = bzflag ] ; then
	for r in 298 722 4194 4195 4197 4198 5793 5794 5943 5997 5998 6006 6007 6008 6084 6130 6162 6170 6171 6204 6455 6456 6459 6492 6654 6706 6789 6909 7461 7462 7468 7587 7828 8480 11953 11974 12096 12102 12103 12104 12205 12355 12362 12450 12523 12524 12529 12550 12653 12797 12801 12803 12815 13008 13053 13152 13226 13247 13300 13328 13581 13585 13653 13654 13655 13656 13660 13664 13665 13667 13679 13680 13706 13782 13801 13842 13913 13915 ; do
		if [ $STARTING_REVISION -le $r -a $r -le $ENDING_REVISION ] ; then
			echo $r
		fi
	done
  fi
) | sort -n > /tmp/$GIT_REPO_NAME.expect
( git log --all | awk '$1 == "git-svn-id:" && $3 == "08b3d480-bf2c-0410-a26f-811ee3361c24" {print substr($2,index($2,"@")+1)}'
  echo -n "$SKIPPED" | tr ' ' \\n
) | sort -n > /tmp/$GIT_REPO_NAME.have
if cmp -s /tmp/$GIT_REPO_NAME.expect /tmp/$GIT_REPO_NAME.have ; then
	echo "All revisions accounted for."
else
	echo "expected vs. actual subversion commits:"
	diff /tmp/$GIT_REPO_NAME.expect /tmp/$GIT_REPO_NAME.have || true
fi
rm /tmp/$GIT_REPO_NAME.expect /tmp/$GIT_REPO_NAME.have
set -x

# change all committer info to match the author's
# move files up out of repo name subdirectory
# (the file name bzFLAG is known not to conflict with anything)
# "--subdirectory-filter bzflag" removes empty commits and so is unsuitable
time git filter-branch --env-filter 'export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME";export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL";export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"' --tree-filter "if mv $TARGET_REPO bzFLAG ; then mv bzFLAG/.??* bzFLAG/* . || true ; rmdir bzFLAG ; fi" -- --all | tr \\r \\n
rm -rf .git/refs/original	# discard old commits saved by filter-branch 

if [ $TARGET_REPO = bzflag -a $NEXT_REVISION -gt $ENDING_REVISION ] ; then
	# import post-Subversion commits
	git checkout trunk		# be sure to start at the right place
	git branch new_v2_6_x		# temporary non-conflicting branch name
	git remote add -f import2 $HOME/bzflag/bzflag-import-2.git
	PARENT=`git rev-parse ':/tag as 2\.5\.x devel'`~	# match the remote commit
	git cherry-pick ${PARENT}..import2/v2_4_x~		# ignore tip commit of r22830 for now
	git branch new_v2_4_x		# temporary non-conflicting branch name
	git checkout new_v2_6_x
	git cherry-pick ${PARENT}..':/^update version'
	PARENT=`git rev-parse ":/^Merge branch 'v2_4_x'"`	# do this now to match the remote commit
	# JeffM would have done this if he were actually committing to the v2_4_x branch
	GIT_AUTHOR_DATE='1373139800 -0700' GIT_AUTHOR_NAME='Jeffery Myers' GIT_AUTHOR_EMAIL='jeffm2501@gmail.com' git merge -q "-mMerge branch 'v2_4_x'" ':/^ingnore more windows temp files'
	git cherry-pick ${PARENT}..':/^Change the BZFlag version number from 2\.4\.3'
	GIT_AUTHOR_DATE='1376370000 -0700' git merge -q '-mMerge branch v2_4_x onto branch v2_6_x.' ':/^For observers,'
	GIT_AUTHOR_DATE='1376861008 -0700' git merge -q '-mMerge recent v2_4_x changes into v2_6_x.' ':/^remove files that were not ready'
	git remote remove import2
	git tag -d `git tag`					# expunge import2 tags
	git branch -m new_v2_4_x v2_4_x
	git branch -m new_v2_6_x v2_6_x
	# remove obsolete Subversion branches and tags that are not branch tips
	git branch -d -r gsoc_08_libbzw tags/pre-mesh tags/v1_7d_6 tags/v1_7d_7 tags/v1_7d_8 tags/v1_7d_9 tags/v1_7temp tags/v1_8abort tags/v1_9_4_Beta tags/v1_9_6_Beta tags/v1_9_7_Beta tags/v1_9_8_Beta tags/v1_9_9_Beta tags/v2_0_10RC3 tags/v2_0_12.deleted v1_10branch v1_8 v2_0branch

	# import late Subversion revision
	rev=22830
	git checkout v2_4_x
	svn diff -c $rev $SVN_REPO | patch -p2
	DATE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<date>==s and s=</date>.*==s and print'`"
	AUTHOR="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<author>==s and s=</author>.*==s and print'`"
	MESSAGE="`svn log --xml -r $rev $SVN_REPO | perl -wle 'undef \$/; \$_ = <>; s=.*<msg>==s and s=</msg>.*==s and print'`"
	LOCATION=trunk
	git commit -a --allow-empty "--date=$DATE" "--author=$AUTHOR" "-m$MESSAGE

git-svn-id: $UPSTREAM_REPO/$LOCATION@$rev $UPSTREAM_UUID"

	# change committer info to match the author's
	git filter-branch --env-filter 'export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME";export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL";export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"' -- trunk..v2_4_x trunk..v2_6_x | tr \\r \\n
	rm -r .git/refs/original	# discard old commits saved by filter-branch 

	git branch -d master					# discard useless old master branch
	git remote add -f blaster $MASTER_REPO			# import master branch
	git branch --track master remotes/blaster/master	# disconnected master branch
	git remote remove blaster				# disconnect from repo
	git checkout master					# default branch
else
	git checkout master
	git merge -q --ff-only trunk
fi

# change Subversion tag branches into Git tags
for branch in `git branch -r` ; do
	case $branch in
	    tags/soc-bzworkbench)
		tag=GSoC_2007
		;;
	    tags/*)
		# change underscores to periods appropriately
		tag=`echo $branch | sed -e 's=^tags/==' -e '/^v/s/_/./' -e '/^v[12]\.[0-9][0-9]*_/s/_/./'`
		;;
	    *)
		continue
		;;
	esac
	git tag $tag $branch
	git branch -d -r $branch
done
git branch -d -r trunk				# "trunk" is a Subversion convention

sleep 1						# let the clock advance
git reflog expire --expire=now --all		# purge reflogs
git gc --prune=now				# rewritten commits be gone!
rm -f .git/COMMIT_EDITMSG .git/FETCH_HEAD	# tidy
rm -r .git/logs/refs/remotes .git/refs/remotes	# tidy
git status --ignored				# update index and show state

exit 0
# Push this to a new empty repo at GitHub:
git remote add origin git@github.com:BZFlag-Dev/bzflag-import-3.git
git push -u origin master
git push -u origin --all
git push -u origin --tags
